(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{453:function(t,s,a){"use strict";a.r(s);var n=a(14),e=Object(n.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h3",{attrs:{id:"什么是虚拟-dom"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是虚拟-dom"}},[t._v("#")]),t._v(" 什么是虚拟 DOM")]),t._v(" "),a("ul",[a("li",[t._v("是对真实 DOM 的引射，就是一个对象")])]),t._v(" "),a("h3",{attrs:{id:"为什么要有虚拟-dom"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么要有虚拟-dom"}},[t._v("#")]),t._v(" 为什么要有虚拟 DOM")]),t._v(" "),a("ol",[a("li",[t._v("真实 DOM 上有一堆的属性和方法，直接操作真实的 DOM 每次都会导致重绘和回流，所以性能差; 操作虚拟 DOM 不存在性能问题，因为他是等数据全部更新完毕之后，只会更新真实 DOM 树需要改变的地方，只有一次重绘和回流")]),t._v(" "),a("li",[t._v("组件初始化的时候创建一个虚拟 DOM 树，数据更新时生成一个新的虚拟 DOM 树，利用 diff 算法广度遍历对新旧 DOM 树一层一层的进行比较")]),t._v(" "),a("li",[t._v("diff 算法\n"),a("ul",[a("li",[t._v("如果是元素变了，删除元素，创建新的元素")]),t._v(" "),a("li",[t._v("如果属性或内容变了，修改属性和内容")]),t._v(" "),a("li",[t._v("使用 v-for 遍历的时候\n"),a("ul",[a("li",[t._v("没有 key 的时候或者 Key 是索引的时候，diff 算法会采用就地复用的原则，再顺序上位置是同一个索引会被认为是同一个元素，使用改变数据顺序的方法的时候，就会导致不需要更新的元素也会更新")]),t._v(" "),a("li",[t._v("当给 key 的值是唯一标识的时候 ，vue 知道 key 一样的就是同一个元素，就不会出现去更新旧的元素的情况")])])])])]),t._v(" "),a("li",[t._v("虚拟 DOM 的作用：可以实现高效更新(数据变了的时候视图更新效率更高),可以实现跨平台(一套代码可以生成不同的平台的最终代码)")])]),t._v(" "),a("h3",{attrs:{id:"数据响应式的原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据响应式的原理"}},[t._v("#")]),t._v(" 数据响应式的原理")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("数据响应式就是数据变了,视图跟着变")])]),t._v(" "),a("li",[a("p",[t._v("利用 Object.defineProperty 数据劫持和观察者模式来实现的")])]),t._v(" "),a("li",[a("p",[t._v("Object.defineProperty 里面有一个 get 和 set 方法。 get 可以返回被劫持的属性的值，set 可以修改被劫持的属性的值,在数据初始化的时候把 data 里面的数据进行转换,每个数据创建一个 Dep(被观察者)")])]),t._v(" "),a("li",[a("p",[t._v("对模板进行编译 (compiler) 提取里面所有需要数据的地方变成 watcher (观察者),然后把 watcher(观察者) 加入到对应的 Dep(被观察者) 的观察者列表中")])]),t._v(" "),a("li",[a("p",[t._v("当 data 中某个属性变化的时候,由于被劫持了,所以 vue 内部是知道的,就会调用对应的 dep(被观察者) 去通知观察者列表中所有的观察者")])]),t._v(" "),a("li",[a("p",[t._v("然后观察者去更新视图")])]),t._v(" "),a("li",[a("p",[t._v("哪种情况数据不是响应式的：")])])]),t._v(" "),a("ul",[a("li",[t._v("通过数组下标修改数组数据 和 对象新增属性")]),t._v(" "),a("li",[t._v("解决方法：this.$set(要修改的数据，要修改的下标(或要增加的属性)，修改(或新增的是什么)成什么)")]),t._v(" "),a("li",[t._v("为什么不响应：新增对象的属性不响应是 Object.defineProperty 只能对已有数据进行劫持 新增的数据是没被劫持的所以也没法去更新"),a("br"),t._v("\n修改数组下标不响应是：object.defineProperty 是可以劫持到这些数据的 但是 vue 基于性能的考虑把这个功能抛弃了")]),t._v(" "),a("li",[t._v("不响应又响应的情况是：修改数组下标或对象属性新增 后面又操作了其他数据 此时是可以拿到数据的 因为当数据发生变化 组件就会更新 组件更新 页面也会更新 他就取到了最新的值")])]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token function"}},[t._v("data")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("arr")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("4")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("methods")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("setArr")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 通过数组下标修改的数组数据不是响应式的")]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 解决方法：")]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("$set")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("arr"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("setobj")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("$set")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("obj"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("name"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'QQ'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n")])])]),a("h3",{attrs:{id:"loader-基本概念"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#loader-基本概念"}},[t._v("#")]),t._v(" loader 基本概念")]),t._v(" "),a("p",[t._v("webpack 是个模块打包器，但是 webpack 只能处理 js 和 json 文件，loader 让 webpack 能够去处理其他类型的文件，并将它们转换为有效模块，以共应用程序使用，以及被添加到依赖图中")])])}),[],!1,null,null,null);s.default=e.exports}}]);