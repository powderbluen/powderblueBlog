(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{450:function(t,_,v){"use strict";v.r(_);var r=v(14),a=Object(r.a)({},(function(){var t=this,_=t.$createElement,v=t._self._c||_;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h3",{attrs:{id:"深拷贝和浅拷贝"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#深拷贝和浅拷贝"}},[t._v("#")]),t._v(" 深拷贝和浅拷贝")]),t._v(" "),v("ol",[v("li",[v("strong",[t._v("浅拷贝")]),t._v("：如果拷贝的属性是基本数据类型，拷贝的是属性值，如果拷贝的是复杂数据类型，拷贝的是内存地址"),v("br"),t._v(" "),v("strong",[t._v("浅拷贝的方式")]),t._v("："),v("br"),t._v("\nObject.assign('要拷贝给谁','拷贝的是哪一个对象')"),v("br"),t._v("\nArray.prototype.slice()"),v("br"),t._v("\n扩展运算符")]),t._v(" "),v("li",[v("strong",[t._v("深拷贝")]),t._v("：开辟一个新的栈，两个对象属性完全相同，但是对应两个不同的地址，修改一个对象的属性，不会改变另一个对象的属性"),v("br"),t._v(" "),v("strong",[t._v("深拷贝的方式")]),t._v("：\n"),v("ul",[v("li",[t._v("JSON.parse(JSON.stringify('要拷贝的对象')) 有一个缺陷会忽略 undefined 和函数")]),t._v(" "),v("li",[t._v("递归循环 如果数据自己引用自己 拷贝会进入死循环 解决方法：使用 map 数据, map 的 key 可以是任意数据类型")]),t._v(" "),v("li",[t._v("loadsh 的.cloneDeep()")])])])]),t._v(" "),v("h3",{attrs:{id:"闭包"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#闭包"}},[t._v("#")]),t._v(" 闭包")]),t._v(" "),v("ol",[v("li",[v("strong",[t._v("什么是闭包")]),t._v("：在内层函数访问它外层函数的作用域")]),t._v(" "),v("li",[t._v("内层函数访问外层函数的变量就会形成闭包")]),t._v(" "),v("li",[v("strong",[t._v("原理")]),t._v("：利用作用域链的特性，先在当前作用域访问数据，如果访问不到，向父级访问，父级没有继续向上一层一层找，一直找到全局")]),t._v(" "),v("li",[v("strong",[t._v("作用")]),t._v("：数据私有化，防止污染全局")]),t._v(" "),v("li",[v("strong",[t._v("缺点")]),t._v("：可能会造成内存泄漏，解决方法：在退出函数之前，将不使用的局部变量全部删除")])]),t._v(" "),v("h3",{attrs:{id:"localstorage、sessionstorage-和-cookie-的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#localstorage、sessionstorage-和-cookie-的区别"}},[t._v("#")]),t._v(" localStorage、sessionStorage 和 cooKie 的区别")]),t._v(" "),v("ol",[v("li",[t._v("localStorage 和 sessionStorage 存储大小 5MB，cookie 存储大小是 4kb")]),t._v(" "),v("li",[t._v("locaStorage 数据得手动删除 sessionStorage 关闭页面或浏览器清除数据; cookie:s 如果在浏览器端生成 cookie 默认是关闭浏览器后失效")]),t._v(" "),v("li",[t._v("localStorage 和 sessionStorage 只在浏览器中保存，不参与和服务器的通信; cookie:与服务器通信的时候每次都会携带在 HTTP 头中 如果使用 cookie 保存过多数据都会带来性能问题")])]),t._v(" "),v("h3",{attrs:{id:"垃圾回收"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收"}},[t._v("#")]),t._v(" 垃圾回收")]),t._v(" "),v("ol",[v("li",[t._v("引用计数：计算当前内存被引用的次数，被引用一次计数+1.不被引用一次计数-1，当计数为 0，该内存释放回收")]),t._v(" "),v("li",[t._v("标记清除：通过根节点，标记所有从根节点开始的能够访问到的对象，未被标记得对象就是未被全局引用的垃圾对象，最终清除所有未被标记的对象")])]),t._v(" "),v("h3",{attrs:{id:"静态成员和实例成员"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#静态成员和实例成员"}},[t._v("#")]),t._v(" 静态成员和实例成员")]),t._v(" "),v("ol",[v("li",[t._v("静态成员：类的属性")]),t._v(" "),v("li",[t._v("实例成员：实例对象的属性")])]),t._v(" "),v("h3",{attrs:{id:"作用域链"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#作用域链"}},[t._v("#")]),t._v(" 作用域链")]),t._v(" "),v("ul",[v("li",[t._v("在某个函数作用域中，要使用一个变量的时候，会先看自己有没有，如果没有就向外面一层层找直到找到全局作用域，如果还没有就报错")])]),t._v(" "),v("h3",{attrs:{id:"如何检测一个数据是数组"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#如何检测一个数据是数组"}},[t._v("#")]),t._v(" 如何检测一个数据是数组")]),t._v(" "),v("ol",[v("li",[t._v("arr instanceof Array")]),t._v(" "),v("li",[t._v("Array.isArray(arr)")]),t._v(" "),v("li",[t._v("Object.prototype.toString.call(arr)")])]),t._v(" "),v("h3",{attrs:{id:"继承"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#继承"}},[t._v("#")]),t._v(" 继承")]),t._v(" "),v("ol",[v("li",[t._v("原型链继承 (只能实现原型上方法的继承) Father.prototype.方法名 = function(){} Son.prototype = new Father() (引用类型值的原型属性会被所有的实例共享)")]),t._v(" "),v("li",[t._v("借用构造函数继承 (只能实现属性的继承) function Son(name) {Father.call(this,name)} 将 Father 类的 this 指向 Son")]),t._v(" "),v("li",[t._v("组合继承 = 原型链+借用构造函数 (原型链继承+借用构造函数继承，可以继承方法也可以继承属性，但是属性继承了两次)")]),t._v(" "),v("li",[t._v("寄生组合继承 Son.prototype = Object.create(Father.prototype)(解决了组合继承的缺陷)")]),t._v(" "),v("li",[t._v("es6 的继承 extends")])]),t._v(" "),v("h3",{attrs:{id:"原型链的理解"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#原型链的理解"}},[t._v("#")]),t._v(" 原型链的理解")]),t._v(" "),v("ol",[v("li",[t._v("实例有__proto__属性，当我们访问实例的属性或方法的时候，会先看自己有没有，没有的话就通过__proto__往自己的原型身上找，如果没找到就继续一层一层往上找，就形成了一条链")])]),t._v(" "),v("h3",{attrs:{id:"构造函数-实例和原型对象的三角关系"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#构造函数-实例和原型对象的三角关系"}},[t._v("#")]),t._v(" 构造函数，实例和原型对象的三角关系")]),t._v(" "),v("ol",[v("li",[t._v("首先创建一个构造函数 构造函数通过 new 创建一个实例")]),t._v(" "),v("li",[t._v("将实例的__proto__指向了构造函数的 prototype")]),t._v(" "),v("li",[t._v("把构造函数的 this 指向这个实例 给这个实例添加属性和方法")]),t._v(" "),v("li",[t._v("此时实例就可以通过__proto__访问到构造函数的 prototype")])]),t._v(" "),v("h3",{attrs:{id:"new-的过程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#new-的过程"}},[t._v("#")]),t._v(" new 的过程")]),t._v(" "),v("ol",[v("li",[t._v("在内存中创建一个空对象")]),t._v(" "),v("li",[t._v("将该空对象的__proto__指向了构造函数的 prototype")]),t._v(" "),v("li",[t._v("将 new 后面的构造函数的 this 指向 new 出来的空对象")]),t._v(" "),v("li",[t._v("把构造函数的属性和方法给这个对象")]),t._v(" "),v("li",[t._v("在构造函数内部返回实例化对象")])]),t._v(" "),v("h2",{attrs:{id:"this-的指向"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#this-的指向"}},[t._v("#")]),t._v(" this 的指向")]),t._v(" "),v("ol",[v("li",[t._v("全局 this 指向 window 严格模式指向 undefined")]),t._v(" "),v("li",[t._v("对象中的 this 指向这个对象")]),t._v(" "),v("li",[t._v("构造函数中 this 指向实例")]),t._v(" "),v("li",[t._v("事件绑定中 this 指向 DOM 元素 btn.onclick = cb 中 this 指向 btn")]),t._v(" "),v("li",[t._v("定时器中 this 指向 window")]),t._v(" "),v("li",[t._v("对象中的方法中定义的函数 this 指向 window")])]),t._v(" "),v("h3",{attrs:{id:"改变-this-指向"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#改变-this-指向"}},[t._v("#")]),t._v(" 改变 this 指向")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("call() apply() bind()方法都可以改变 this 指向\n区别")])]),t._v(" "),v("li",[v("p",[t._v("Call,apply 会立即调用，bind 不会立即调用，返回一个新的函数")])]),t._v(" "),v("li",[v("p",[t._v("apply 只有两个参数，第一个参数是调用者，第二个参数是函数的实参")])]),t._v(" "),v("li",[v("p",[t._v("使用场景")])])]),t._v(" "),v("ul",[v("li",[t._v("call 可以用于借用构造函数继承的实现")]),t._v(" "),v("li",[t._v("apply 可以用来求最大值")])]),t._v(" "),v("h3",{attrs:{id:"跨域"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#跨域"}},[t._v("#")]),t._v(" 跨域")]),t._v(" "),v("ol",[v("li",[t._v("浏览器存在一个同源策略，必须域名、IP、端口三个全部一样才能同源，否则就是跨域，ajax 默认情况拿跨域的数据会报错，这个现象是浏览器的安全策略导致")])]),t._v(" "),v("h3",{attrs:{id:"解决跨域的问题的方案"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#解决跨域的问题的方案"}},[t._v("#")]),t._v(" 解决跨域的问题的方案")]),t._v(" "),v("ol",[v("li",[t._v("jsonp 原理利用 script 标签可以跨域 服务器要返回给前端一个函数的调用，把数据放在实参里面，前端准备好一个全局函数，函数名字要和后台数据函数名一致(只支持 get 请求)")]),t._v(" "),v("li",[t._v("cors(类似白名单)")]),t._v(" "),v("li",[t._v("反向代理 开发的时候在 vue.config.js 中设置 proxy")])]),t._v(" "),v("h3",{attrs:{id:"什么是模块化"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#什么是模块化"}},[t._v("#")]),t._v(" 什么是模块化")]),t._v(" "),v("ul",[v("li",[t._v("不把所有的 js 代码放在一个文件中，因为难以维护，变量命易起冲突,代码尽量一个功能一个 js 文件，一个文件最好要有一个自己的作用域，不会和别的文件起冲突,文件最终要合在一起，所以还有一个导入，这就是模块化")])]),t._v(" "),v("h3",{attrs:{id:"学过那些模块化的方案"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#学过那些模块化的方案"}},[t._v("#")]),t._v(" 学过那些模块化的方案")]),t._v(" "),v("p",[t._v("ES6 的模块化规范"),v("br"),t._v("\nExport default export 导出"),v("br"),t._v("\nimport 导入")]),t._v(" "),v("h3",{attrs:{id:"数组的方法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#数组的方法"}},[t._v("#")]),t._v(" 数组的方法")]),t._v(" "),v("ol",[v("li",[t._v("es3\n(1) Join"),v("br"),t._v("\n(2) Sort"),v("br"),t._v("\n(3) Reverse"),v("br"),t._v("\n(4) Concat"),v("br"),t._v("\n(5) Push"),v("br"),t._v("\n(6) Pop"),v("br"),t._v("\n(7) Splice"),v("br"),t._v("\n(8) Shift"),v("br"),t._v("\n(9) Unshift"),v("br"),t._v("\n(10) slice")]),t._v(" "),v("li",[t._v("es5\n(1) Map"),v("br"),t._v("\n(2) Filter"),v("br"),t._v("\n(3) Reduce 一堆数据加在一起"),v("br"),t._v("\n(4) Some"),v("br"),t._v("\n(5) Every")]),t._v(" "),v("li",[t._v("es6\n(1) Find"),v("br"),t._v("\n(2) findIndex")])])])}),[],!1,null,null,null);_.default=a.exports}}]);