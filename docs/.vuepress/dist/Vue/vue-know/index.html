<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>vue 的核心、优点 | 杰尼龟的知识空间</title>
    <meta name="generator" content="VuePress 1.9.7">
    
    <meta name="description" content="">
    
    <link rel="preload" href="/powderblueBlog/assets/css/0.styles.17348205.css" as="style"><link rel="preload" href="/powderblueBlog/assets/js/app.79abdad2.js" as="script"><link rel="preload" href="/powderblueBlog/assets/js/2.a2f218dc.js" as="script"><link rel="preload" href="/powderblueBlog/assets/js/17.599efe6c.js" as="script"><link rel="prefetch" href="/powderblueBlog/assets/js/10.0ab88e72.js"><link rel="prefetch" href="/powderblueBlog/assets/js/11.95764ad6.js"><link rel="prefetch" href="/powderblueBlog/assets/js/12.7953ce97.js"><link rel="prefetch" href="/powderblueBlog/assets/js/13.4c782cc5.js"><link rel="prefetch" href="/powderblueBlog/assets/js/14.60e34d90.js"><link rel="prefetch" href="/powderblueBlog/assets/js/15.2849b53c.js"><link rel="prefetch" href="/powderblueBlog/assets/js/16.5fa0b3f6.js"><link rel="prefetch" href="/powderblueBlog/assets/js/3.59880b52.js"><link rel="prefetch" href="/powderblueBlog/assets/js/4.2a9537eb.js"><link rel="prefetch" href="/powderblueBlog/assets/js/5.e5513792.js"><link rel="prefetch" href="/powderblueBlog/assets/js/6.8dcd4e8f.js"><link rel="prefetch" href="/powderblueBlog/assets/js/7.3180cc23.js"><link rel="prefetch" href="/powderblueBlog/assets/js/8.a82ed3c9.js"><link rel="prefetch" href="/powderblueBlog/assets/js/9.737f6472.js">
    <link rel="stylesheet" href="/powderblueBlog/assets/css/0.styles.17348205.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/powderblueBlog/" class="home-link router-link-active"><!----> <span class="site-name">杰尼龟的知识空间</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/powderblueBlog/" class="nav-link">
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端三剑客" class="dropdown-title"><span class="title">前端三剑客</span> <span class="arrow down"></span></button> <button type="button" aria-label="前端三剑客" class="mobile-dropdown-title"><span class="title">前端三剑客</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/powderblueBlog/ThreeSwordsman/HTMLandCSS-Topic/" class="nav-link">
  HTMLandCSS
</a></li><li class="dropdown-item"><!----> <a href="/powderblueBlog/ThreeSwordsman/JavaScript-Topic/" class="nav-link">
  JavaScript
</a></li><li class="dropdown-item"><!----> <a href="/powderblueBlog/ThreeSwordsman/LESSandSCSS/" class="nav-link">
  LESSandSCSS
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Vue" class="dropdown-title"><span class="title">Vue</span> <span class="arrow down"></span></button> <button type="button" aria-label="Vue" class="mobile-dropdown-title"><span class="title">Vue</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/powderblueBlog/vue/vue-know/" class="nav-link">
  Vue2基础面视题
</a></li><li class="dropdown-item"><!----> <a href="/powderblueBlog/vue/vue-hard/" class="nav-link">
  Vue难点面视题
</a></li><li class="dropdown-item"><!----> <a href="/powderblueBlog/vue/Vue3/" class="nav-link">
  Vue3
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="综合" class="dropdown-title"><span class="title">综合</span> <span class="arrow down"></span></button> <button type="button" aria-label="综合" class="mobile-dropdown-title"><span class="title">综合</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/powderblueBlog/Comprehensive/CommonTopic/" class="nav-link">
  常见面试题
</a></li><li class="dropdown-item"><!----> <a href="/powderblueBlog/Comprehensive/Rendering/" class="nav-link">
  常见面试题2
</a></li><li class="dropdown-item"><!----> <a href="/powderblueBlog/Comprehensive/RBAC/" class="nav-link">
  权限控制怎么做
</a></li><li class="dropdown-item"><!----> <a href="/powderblueBlog/Comprehensive/ProjectExperience/" class="nav-link">
  项目经验
</a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/powderblueBlog/" class="nav-link">
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端三剑客" class="dropdown-title"><span class="title">前端三剑客</span> <span class="arrow down"></span></button> <button type="button" aria-label="前端三剑客" class="mobile-dropdown-title"><span class="title">前端三剑客</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/powderblueBlog/ThreeSwordsman/HTMLandCSS-Topic/" class="nav-link">
  HTMLandCSS
</a></li><li class="dropdown-item"><!----> <a href="/powderblueBlog/ThreeSwordsman/JavaScript-Topic/" class="nav-link">
  JavaScript
</a></li><li class="dropdown-item"><!----> <a href="/powderblueBlog/ThreeSwordsman/LESSandSCSS/" class="nav-link">
  LESSandSCSS
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Vue" class="dropdown-title"><span class="title">Vue</span> <span class="arrow down"></span></button> <button type="button" aria-label="Vue" class="mobile-dropdown-title"><span class="title">Vue</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/powderblueBlog/vue/vue-know/" class="nav-link">
  Vue2基础面视题
</a></li><li class="dropdown-item"><!----> <a href="/powderblueBlog/vue/vue-hard/" class="nav-link">
  Vue难点面视题
</a></li><li class="dropdown-item"><!----> <a href="/powderblueBlog/vue/Vue3/" class="nav-link">
  Vue3
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="综合" class="dropdown-title"><span class="title">综合</span> <span class="arrow down"></span></button> <button type="button" aria-label="综合" class="mobile-dropdown-title"><span class="title">综合</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/powderblueBlog/Comprehensive/CommonTopic/" class="nav-link">
  常见面试题
</a></li><li class="dropdown-item"><!----> <a href="/powderblueBlog/Comprehensive/Rendering/" class="nav-link">
  常见面试题2
</a></li><li class="dropdown-item"><!----> <a href="/powderblueBlog/Comprehensive/RBAC/" class="nav-link">
  权限控制怎么做
</a></li><li class="dropdown-item"><!----> <a href="/powderblueBlog/Comprehensive/ProjectExperience/" class="nav-link">
  项目经验
</a></li></ul></div></div> <!----></nav>  <!----> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="vue-的核心、优点"><a href="#vue-的核心、优点" class="header-anchor">#</a> vue 的核心、优点</h2> <ul><li>组件化 可以实现页面上功能的复用</li> <li>数据驱动 会让代码变得简单，不用去操作 DOM，只要更新数据，视图会跟着变化</li> <li>虚拟 dom 不用频繁操作真实的 DOM（真实 DOM 操作性能很慢） 性能会高一些</li></ul> <h2 id="v-el-通过-v-el-可以获取到-dom-对象"><a href="#v-el-通过-v-el-可以获取到-dom-对象" class="header-anchor">#</a> v-el:通过 v-el 可以获取到 DOM 对象</h2> <h2 id="单向数据流-a-能到-b-a-b-反过来不行"><a href="#单向数据流-a-能到-b-a-b-反过来不行" class="header-anchor">#</a> 单向数据流 (a 能到 b a-&gt;b 反过来不行)</h2> <ul><li>父组件通过 props 向子组件传值 父组件中的数据变了，子组件中 props 数据也跟着变，子组件不能修改 props 里的数据 因为 props 是只读的</li> <li>特殊情况：如果是引用类型数据，子组件只要不修改数据的地址，是可以在子组件中修改的（可以改属性）</li></ul> <h3 id="vue-的修饰符"><a href="#vue-的修饰符" class="header-anchor">#</a> vue 的修饰符</h3> <ol><li>事件修饰符：</li></ol> <ul><li>.stop 阻止事件继续传播</li> <li>.prevent 阻止标签默认行为</li> <li>.self 只当在 event.target 是当前元素自身时触发处理函数</li> <li>.once 事件将只会触发一次</li> <li>.sync 当我们想在父组件和子组件之间对某个属性值进行双向绑定时</li></ul> <ol start="2"><li>v-model 修饰符:</li></ol> <ul><li>.lazy 默认情况下，v-model 同步输入框的值和数据。可以通过这个修饰符，转变为在 change 事件再同步。</li> <li>.number 自动将用户的输入值转化为数值类型</li> <li>.trim 自动过滤用户输入的首尾空格</li></ul> <ol start="3"><li>键盘事件的修饰符</li></ol> <ul><li>.enter 敲击回车触发</li></ul> <h3 id="mvvm-和-mvc-的区别"><a href="#mvvm-和-mvc-的区别" class="header-anchor">#</a> MVVM 和 MVC 的区别</h3> <ol><li>MVC:</li></ol> <ul><li>model:(数据模型)数据访问层 view:视图 controller:(控制器)业务逻辑层</li> <li>view 通过一些事件操作去通知 controller controller 去改变 model model 处理数据后通知 view 去更新</li> <li>开发过程不灵活 一个小的事件操作也要走一遍这个流程</li> <li>MVC 是单向通信，也就是将 Model 渲染到 View 上，必须通过 Controller 来承上启下</li></ul> <ol start="2"><li>MVVM:</li></ol> <ul><li>MVVM 是三个单词的缩写 model(数据模型) + view(视图) + viewmodel(公共属性)</li> <li>view 和 model 没有直接关联 通过 viewmodel 进行通信
<ul><li>model 和 view 就像现实中房东和租客一样，他们是不认识，通过中介 viewmodel</li></ul></li> <li>好处
<ul><li>数据驱动
<ul><li>数据与页面的双向绑定</li></ul></li> <li>解耦（降低了耦合性）
<ul><li>由于 model 和 view 是没有关系的，是通过 viewmodel 结合在一起的，所以维护起来很方便</li></ul></li></ul></li></ul> <h2 id="事件传参"><a href="#事件传参" class="header-anchor">#</a> 事件传参</h2> <ul><li>@click=&quot;fn&quot; 在回调函数直接通过参数可以拿到事件对象</li> <li>@click=&quot;fn($event)&quot; 这个时候$event 是固定写法</li></ul> <h2 id="对-event-的理解"><a href="#对-event-的理解" class="header-anchor">#</a> 对$event 的理解</h2> <ul><li>在原生 DOM 原生事件中，$event 指的是事件源对象</li> <li>在组件自定义事件，$event 代表的是子组件抛出的数据</li></ul> <h2 id="自定义指令-directive"><a href="#自定义指令-directive" class="header-anchor">#</a> 自定义指令：directive</h2> <ul><li><p>你平时用过自定义指令</p> <ul><li>v-imgerror 我们公司项目中有的用户头像可能加载报错，可以给他一张默认图片， onerror this.img=默认图片</li> <li>v-focus 打开带有搜索的页面的时候，想实现自动把光标定位到 input 中</li></ul></li> <li><p>自定义指令的钩子函数</p> <ul><li>bind 属性绑定的时候执行 只会有一次</li> <li>inserted 当前指令所在的元素插入到页面中的时候执行一次</li> <li>update 当前指令所在的组件中的 data 数据有更新就会执行，可以执行多次</li></ul></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 指令的钩子有三个 bind inserted update</span>
<span class="token comment">// bind inserted 只会执行一次</span>
<span class="token comment">// update 会反复执行</span>
Vue<span class="token punctuation">.</span><span class="token function">directive</span><span class="token punctuation">(</span><span class="token string">'focus'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token function">inserted</span><span class="token punctuation">(</span><span class="token parameter">el</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    el<span class="token punctuation">.</span><span class="token function">focus</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

Vue<span class="token punctuation">.</span><span class="token function">directive</span><span class="token punctuation">(</span><span class="token string">'red'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token function">bind</span><span class="token punctuation">(</span><span class="token parameter">el</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    el<span class="token punctuation">.</span>style<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token string">'red'</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

Vue<span class="token punctuation">.</span><span class="token function">directive</span><span class="token punctuation">(</span><span class="token string">'check'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token function">update</span><span class="token punctuation">(</span><span class="token parameter">el</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> reg <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">^[a-zA-Z0-9]+$</span><span class="token regex-delimiter">/</span></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>reg<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>el<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      el<span class="token punctuation">.</span>style<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token string">'green'</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      el<span class="token punctuation">.</span>style<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token string">'red'</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><h2 id="v-model-语法糖原理"><a href="#v-model-语法糖原理" class="header-anchor">#</a> v-model 语法糖原理</h2> <p>通过 v-bind:value 绑定一个 str 变量，绑定一个 input 事件，每次输入内容时触发 input 事件，
通过事件对象参数$event.target.value 获得输入的内容,把内容赋给 str 变量
然后更改 str 变量的值时 input 输入框的内容会发生变化，更改 input 输入框内容时 str 变量也会变</p> <h3 id="keep-alive-缓存组件"><a href="#keep-alive-缓存组件" class="header-anchor">#</a> Keep-alive:缓存组件</h3> <ol><li>组件在进行切换的时候默认会进行销毁，如果有一个需求要切换组件后不销毁 保留原状态 就可以用 keepalive 进行缓存</li> <li>include - 只有名称匹配的组件会被缓存。<br>
exclude - 任何名称匹配的组件都不会被缓存<br>
max （数字）最多可以缓存多少组件实例</li> <li>两个钩子函数：activated:进入已缓存的组件时触发 deactivated:离开缓存组件时触发</li> <li>应用场景：比如用户从商品列表页 去到其他页面，然后再回到商品列表页 希望页面的滚动位置是上一次用户离开的位置</li> <li>实现方法:给路由外面包裹 keep-alive，让 商品列表 组件切换出去后不被销毁，而是缓存 然后：</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">return</span><span class="token operator">:</span><span class="token punctuation">{</span>
    <span class="token literal-property property">saceY</span><span class="token operator">:</span><span class="token number">0</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
 <span class="token function">activated</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
   <span class="token comment">// 进入的时候给固定的位置</span>
   <span class="token keyword">this</span><span class="token punctuation">.</span>$refs<span class="token punctuation">.</span>scroll<span class="token punctuation">.</span>scroll<span class="token punctuation">.</span><span class="token function">scrollTo</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token keyword">this</span><span class="token punctuation">.</span>saceY<span class="token punctuation">,</span><span class="token number">200</span><span class="token punctuation">)</span> <span class="token comment">//z轴, y轴, 时间</span>
 	<span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token comment">///然后处理用户离开之前的滚动位置</span>
<span class="token function">deactivated</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">// 切换出去后赋值</span>
 <span class="token keyword">this</span><span class="token punctuation">.</span>saceY <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$refs<span class="token punctuation">.</span>scroll<span class="token punctuation">.</span><span class="token function">getScrollY</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
 	<span class="token punctuation">}</span><span class="token punctuation">,</span>
</code></pre></div><h3 id="vue-性能优化"><a href="#vue-性能优化" class="header-anchor">#</a> vue 性能优化</h3> <ol><li>路由懒加载 component:() =&gt; import() 按需加载</li> <li>keepalive 对组件进行缓存</li> <li>v-show 复用组件</li> <li>第三方组件库按需引入 比如 element-ui</li> <li>图片懒加载 v-lazyload 插件</li> <li>函数式组件(将只展示数据的组件转为函数式组件(标记为 Function))</li></ol> <h2 id="v-if-和-v-for-为什么要避免使用同一个组件或元素上"><a href="#v-if-和-v-for-为什么要避免使用同一个组件或元素上" class="header-anchor">#</a> v-if 和 v-for 为什么要避免使用同一个组件或元素上</h2> <ul><li>原因：v-for 的优先级要高 同时作用再一个元素上 每次渲染都会先循环再进行条件判断 会带来性能方面的浪费</li> <li>比如数据里面有个 isShow 变量 为 true 才去显示他 总不能每次循环都去判断一下 对性能浪费 可以在 computed 里提前过滤</li> <li>解决：</li> <li>在外层嵌套 template v-if 再外层判断 再里层循环</li> <li>如果再循环内部出现条件 可以用计算属性 computed 提前过滤掉不需要显示的项</li></ul> <h2 id="为什么-data-是一个函数"><a href="#为什么-data-是一个函数" class="header-anchor">#</a> 为什么 data 是一个函数</h2> <ol><li>Vue 组件可能存在多个实例，如果使用对象定义 data，数据就会共用一个 data 对象，当一个状态发生变化大的时候 另一个也会受到影响</li> <li>采用函数形式定义 实例被创建的时候每次都执行一次这个函数 所以会每次都创建一个新的 data 对象，指向不同的引用，相互不会影响</li> <li>为什么跟实例没有这个限制：跟实例在整个应用程序中只有一个 不会创建多个</li></ol> <h2 id="v-if-和-v-show-的区别"><a href="#v-if-和-v-show-的区别" class="header-anchor">#</a> v-if 和 v-show 的区别</h2> <ul><li><p>相同点：v-if,v-show 实现的效果是一样的，都是控制显示和隐藏</p></li> <li><p>不同点:</p></li> <li><p>原理上</p></li> <li><div class="language- extra-class"><pre><code> v-show是通过控制样式的display:none来实现的
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> v-if是通过创建和销毁元素来实现的
</code></pre></div></li> <li><p>适用场景</p></li> <li><div class="language- extra-class"><pre><code>v-show哪怕是false的时候也会创建并隐藏，适合频繁切换(显示隐藏一般用的v-if 对大的组件需要复用的可以用v-show  提高性能)
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>v-if如果是false直接不创建，适合切换不频繁的时候
</code></pre></div></li></ul> <h3 id="nexttick"><a href="#nexttick" class="header-anchor">#</a> nextTick()</h3> <ul><li>应用场景：再 cerated 中进行 DOM 操作一定要放在 Vue.nextTick()的回调函数中。</li> <li>原因：Vue 在更新 data 之后并不会立即更新 DOM 上的数据，如果修改了 data 中的数据，再马上获取 DOM 上的值，取得的是旧值，把获取 DOM 上值的操作放在$nextTick()里就可以得到更新后的数据</li></ul> <h3 id="vuex"><a href="#vuex" class="header-anchor">#</a> Vuex</h3> <ol><li>vuex 是多个组件用来共享数据的一个状态管理容器</li> <li>核心概念：<br>
state：存放数据的地方
Mutations：用于修改 state 里的数据 类似于组件里的 methods
Actions：提交 mutations 通过 mutations 修改 state 可以写异步代码
Getters：将 state 里的数据处理成新的数据 类似于计算属性<br>
Modeles：把 store 进行模块化</li> <li>辅助函数：mapstate mapMutations mapActions mapGetters createNamespateHelpers</li> <li>vuex 的数据是响应式的，组件可以方便的用 vuex 进行数据存取 但是不能刷新页面会导致数据的丢失 需要结合本地存储实现数据的持久化</li> <li>项目中 vuex 代码是怎么组织的：store 目录说一下</li></ol> <h3 id="组件通信"><a href="#组件通信" class="header-anchor">#</a> 组件通信</h3> <ol><li><p>父子:<br>
props 父向子
$emit 子向父
$parent $children
ref</p></li> <li><p>兄弟：<br>
Event bus<br>
在使用数据的地方 EventBus.$on<br>
在传数据的地方用EventBUs.$emit</p></li> <li><p>隔代：<br>
在祖先身上写 provide (依赖注入)
在任何一个子代中通过 inject 拿数据</p> <div class="language-js extra-class"><pre class="language-js"><code>expoer defaule<span class="token punctuation">{</span>
  <span class="token literal-property property">provide</span><span class="token operator">:</span><span class="token punctuation">{</span>
    <span class="token literal-property property">c</span><span class="token operator">:</span><span class="token number">400</span>  <span class="token comment">//祖先级 提供数据</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">inject</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'c'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token comment">//子孙级别 拿数据</span>
<span class="token punctuation">}</span>

</code></pre></div><p><strong>生命周期的概念</strong></p></li></ol> <ul><li>组件从创建到销毁的过程称为生命周期</li> <li>四大阶段 八个钩子函数 ：
<ol><li>初始化： beforeCreate： 组件实列创建了，自身的方法也有了，data 和 methods 数据和方法还没有初始化<br>
created： data 和 methods 数据和方法有了 可以发送 ajax 请求获取数据</li> <li>挂载：beforeMount： 模板已经在内存在编辑完成了 但是还没有渲染到页面<br>
mounted:dom 挂载好了 页面一进来需要操作 dom 可以在这里</li> <li>更新：beforeUpdate:数据更新了 视图还没更新<br>
updated:数据和视图都是最新的</li> <li>销毁：beforeDestroy：实例的 data 和 methods 还可以用销毁前(清除定时器，事件)<br>
destroyed：组件已经销毁了 组件中的实例和方法都无法使用了</li></ol></li></ul> <h3 id="vue-的父组件和子组件生命周期执行顺序"><a href="#vue-的父组件和子组件生命周期执行顺序" class="header-anchor">#</a> Vue 的父组件和子组件生命周期执行顺序</h3> <ol><li><p>初始化和挂载过程<br>
父 beforeCreate -&gt; 父 created -&gt; 父 beforeMount -&gt; 子 beforeCreate -&gt; 子 created -&gt; 子 beforeMount -&gt; 子 mounted -&gt; 父 mounted</p></li> <li><p>更新过程<br>
父 beforeUpdate -&gt; 子 beforeUpdate -&gt; 子 updated -&gt; 父 updated</p></li> <li><p>销毁过程<br>
父 beforeDestroy -&gt; 子 beforeDestroy -&gt; 子 destroyed -&gt; 父 destroyed</p> <h3 id="v-model-底层原理"><a href="#v-model-底层原理" class="header-anchor">#</a> v-model 底层原理:</h3> <ul><li>在输入框给 v-bind:value 绑定一个 str 变量，绑定一个 input 事件，每次输入内容都会触发 input 事件，</li> <li>通过事件对象参数$event.target.value 获取到输入的内容，把内容赋给 str 变量</li> <li>此时修改 str 变量的值输入框的内容会发生变化，修改输入框的内容 str 变量也会跟着变</li></ul></li></ol> <h2 id="路由守卫"><a href="#路由守卫" class="header-anchor">#</a> 路由守卫</h2> <h3 id="全局守卫"><a href="#全局守卫" class="header-anchor">#</a> 全局守卫</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 全局路由前置守卫</span>
<span class="token comment">//路由进入之前触发</span>
<span class="token comment">// 可做权限控制</span>
router<span class="token punctuation">.</span><span class="token function">beforeEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> from<span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// to：到哪去  from:从哪来</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'触发路由前置守卫'</span><span class="token punctuation">)</span>
  <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// 全局路由后置首位</span>
<span class="token comment">// 路由进入之后触发</span>
<span class="token comment">// 可做登录后弹出欢迎提示等</span>
router<span class="token punctuation">.</span><span class="token function">afterEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> <span class="token keyword">from</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// 场景：判断用户是否登录 如果未登录 且当前处于非登录页面 则自动跳转到登录页</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'触发路由后置守卫'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><h3 id="路由独享守卫-可以直接在路由配置上定义"><a href="#路由独享守卫-可以直接在路由配置上定义" class="header-anchor">#</a> 路由独享守卫 :可以直接在路由配置上定义</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">{</span>
        <span class="token literal-property property">path</span><span class="token operator">:</span> <span class="token string">'/user'</span><span class="token punctuation">,</span>
        <span class="token literal-property property">component</span><span class="token operator">:</span> User<span class="token punctuation">,</span>
        <span class="token function-variable function">beforeEnter</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            <span class="token comment">// to from next 三个参数</span>
            <span class="token comment">//next() 通过</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span> <span class="token comment">//跳转不到user路由</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre></div><h3 id="组件内置守卫-在组件内执行的钩子函数-写在组件里"><a href="#组件内置守卫-在组件内执行的钩子函数-写在组件里" class="header-anchor">#</a> 组件内置守卫:在组件内执行的钩子函数(写在组件里)</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">beforeRouterEnter</span><span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span>from<span class="token punctuation">,</span>next</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token comment">//再进入组件对应的路由时被调用</span>
  <span class="token comment">//不能获取组件实例this 因为该组件执行时，组件实例还没创建</span>
  <span class="token comment">// 写next() 才能进入该组件</span>
<span class="token punctuation">}</span>

<span class="token function">beforeRouterUpdate</span><span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span>from<span class="token punctuation">,</span>next</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token comment">// 在当前路由改变但组件被复用时调用</span>
<span class="token punctuation">}</span>

<span class="token function">beforeRoureLeave</span><span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span>from<span class="token punctuation">,</span>next</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token comment">// 离开该组件对应的路由时会被调用</span>
  <span class="token comment">// 应用场景:比如拼多多提示就差0.01分就能拆红包了 确定要离开吗</span>
  <span class="token comment">// next() 写这个才能离开</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="vue-路由的两种模式"><a href="#vue-路由的两种模式" class="header-anchor">#</a> vue 路由的两种模式：</h3> <ol><li>出现原因：vue 项目是单页面应用 只有一个 html 文件 切换页面要让访问的 url 发生变化 又不能让 html 重新加载 所以 VueRouter 提供了两种加载和跳转方式</li> <li>hash:hash 模式是把前端路由的路径用#拼接在真实路径之后的，当#后面的路径发生变化时 浏览器不会重新发起请求而是会触发 hashchange 事件</li> <li>history 模式：是通过 H5 新增的 api：pushState()和 replaceState()这两个 API 可以在不进行刷新的情况下，操作浏览器的历史纪录。唯一不同的是，前者是新增一个历史记录，后者是直接替换当前的历史记录</li></ol> <h3 id="router-和-route-的区别"><a href="#router-和-route-的区别" class="header-anchor">#</a> router 和 route 的区别:</h3> <ul><li><strong>router</strong> $router 是 VueRouter 的实例对象，它包含所有的路由，用来实现路由之间跳转，以及钩子函数 beforeEach,afterEach</li> <li><strong>route</strong> 是路由信息对象，每一个路由都会有一个 route 对象，主要包含路由的一些基本信息比如 params.query</li></ul> <h2 id="路由传参"><a href="#路由传参" class="header-anchor">#</a> 路由传参</h2> <ol><li>params 传参:path:'/home/:id'(通过/传参) 接收参数： this.$route.params.id</li> <li>query 传参: '/home?id=10'(通过?传参) 接收参数： this.$route.query.id</li></ol> <h3 id="路由传值的区别"><a href="#路由传值的区别" class="header-anchor">#</a> 路由传值的区别</h3> <ul><li>params 穿的参数刷新页面就会丢失 query 参数不会丢失</li> <li>query 在浏览器地址栏中显示参数，params 不显示</li></ul></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"><div class="Sakura" data-v-248d85d6><canvas id="canvas_sakura" style="z-index:9999;" data-v-248d85d6></canvas></div><div class="reco-bgm-panel" data-v-b1d3339e><audio id="bgm" src="https://assets.smallsunnyfox.com/music/2.mp3" data-v-b1d3339e></audio> <div class="reco-float-box" style="bottom:30px;z-index:999999;display:none;" data-v-b1d3339e data-v-41bcba48 data-v-b1d3339e><img src="https://assets.smallsunnyfox.com/music/2.jpg" data-v-b1d3339e></div> <div class="reco-bgm-box" style="left:10px;bottom:10px;z-index:999999;" data-v-b1d3339e data-v-41bcba48 data-v-b1d3339e><div class="reco-bgm-cover" style="background-image:url(https://assets.smallsunnyfox.com/music/2.jpg);" data-v-b1d3339e><div class="mini-operation" style="display:none;" data-v-b1d3339e><i class="reco-bgm reco-bgm-pause" style="display:none;" data-v-b1d3339e></i> <i class="reco-bgm reco-bgm-play" style="display:none;" data-v-b1d3339e></i></div> <div class="falut-message" style="display:none;" data-v-b1d3339e>
          播放失败
        </div></div> <div class="reco-bgm-info" data-v-b1d3339e data-v-41bcba48 data-v-b1d3339e><div class="info-box" data-v-b1d3339e><i class="reco-bgm reco-bgm-music music" data-v-b1d3339e></i>강남역 4번 출구</div> <div class="info-box" data-v-b1d3339e><i class="reco-bgm reco-bgm-artist" data-v-b1d3339e></i>Plastic / Fallin` Dild</div> <div class="reco-bgm-progress" data-v-b1d3339e><div class="progress-bar" data-v-b1d3339e><div class="bar" data-v-b1d3339e></div></div></div> <div class="reco-bgm-operation" data-v-b1d3339e><i class="reco-bgm reco-bgm-last last" data-v-b1d3339e></i> <i class="reco-bgm reco-bgm-pause pause" style="display:none;" data-v-b1d3339e></i> <i class="reco-bgm reco-bgm-play play" data-v-b1d3339e></i> <i class="reco-bgm reco-bgm-next next" data-v-b1d3339e></i> <i class="reco-bgm reco-bgm-volume1 volume" data-v-b1d3339e></i> <i class="reco-bgm reco-bgm-mute mute" style="display:none;" data-v-b1d3339e></i> <div class="volume-bar" data-v-b1d3339e><div class="bar" data-v-b1d3339e></div></div></div></div> <div class="reco-bgm-left-box" data-v-b1d3339e data-v-41bcba48 data-v-b1d3339e><i class="reco-bgm reco-bgm-left" data-v-b1d3339e></i></div></div></div><canvas id="vuepress-canvas-cursor"></canvas></div></div>
    <script src="/powderblueBlog/assets/js/app.79abdad2.js" defer></script><script src="/powderblueBlog/assets/js/2.a2f218dc.js" defer></script><script src="/powderblueBlog/assets/js/17.599efe6c.js" defer></script>
  </body>
</html>
